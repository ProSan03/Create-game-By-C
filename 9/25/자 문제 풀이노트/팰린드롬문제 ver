switch 를 이용 할 수도 있다.
EX)
int A = 0

lf (A) => False 안돌아감
{
 A = 1
}

else
{
 A = 0
}
이라면

어떤 if는 0일 수도, 1일 수도 있다.

(입력받고)
1. 자리수 구하기 알고리즘 생성
	int input, length 변수 두개로 풀 수 있음// 언제끝날지 모를 떄 = while 을 씀. 반대는 for
2. 반으로 나눴을 때 전반부 10^4 = 1, 10^3 = 12
(12421 을 넣을 때)
	pow를 써서 자리수 판단 
	Ex) 5자리 수 = 10^4
10^4 = 1 % 10 
10^3 = 12 % 10
for문으로 로직
3. 후반부 
12421 % 10 = 1
         /  10 = 1242

if 걸고 앞부분 = 뒷부분 반복


pow(X, Y) == 하나의 결과 값이라고 생각
예를 들어)
A = B 라고 할 때, B를 pow(X,Y)로 생각


조건식 

13231
<결과의 값은 No>

입력: 33223
%10^N
3
2
2
3
3
0 --- 6개?

입력: 33223
/10^N
3222
322
32
3
0 --- 5개

/를 했을 때, 오른쪽에서 하나씩 줄어드는 구조
15751 / 10 = 1575
15751 / 100 = 157
15751 / 1000 = 15
15751 / 10000 = 1
15751 / 100000 = 0

%를 했을 때, 왼쪽에서 하나씩 늘어나는 구조
15751 % 10 = 1
15751 % 100 = 51
15751 % 1000 = 751
15751 % 10000 = 5751
15751 % 100000 = 15751

문제는 결국 둘다 0이 되면서 Pront == Back 값이 0 = 0 이기 때문에 무조건 True가 됨.
-> 0으로 무한반복 하지 않게끔 설계. 

한번하고 비교하고 (시작과 끝)
한번하고 비교하고 (시작과 끝)
한번하고 비교하고 (시작과 끝) 무한 반복되게
if 판정문을 반복하도록 = 다맞으면 OK
반복 도중 하나라도 조지면 = Fail.
